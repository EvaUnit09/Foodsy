# User Authentication System Documentation

This document outlines the comprehensive user authentication system implemented for FoodieFriends, including security best practices, validation rules, and implementation details.

## Overview

The FoodieFriends authentication system provides commercial-grade security with both email/password registration and Google OAuth2 integration. The system follows enterprise security standards and includes comprehensive validation, real-time feedback, and secure data handling.

## Architecture

### Backend Components

#### Domain Models
- **User Entity**: Core user model with comprehensive fields
- **AuthProvider Enum**: LOCAL, GOOGLE, FACEBOOK, GITHUB
- **DietaryPreference Enum**: 12 dietary options (Vegetarian, Vegan, etc.)

#### Security Features
- **Password Hashing**: BCrypt with salt rounds
- **Input Sanitization**: XSS and injection prevention
- **Custom Validators**: Password and username validation
- **OAuth2 Integration**: Spring Security OAuth2 with Google

#### Validation System
- **Bean Validation (JSR-380)**: Annotation-based validation
- **Custom Password Validator**: Complex security requirements
- **Custom Username Validator**: Professional naming standards
- **Real-time Availability**: Debounced username/email checking

### Frontend Components

#### Authentication Pages
- **Sign In Page**: `/auth/signin` - Email/password + Google OAuth2
- **Sign Up Page**: `/auth/signup` - Comprehensive registration form
- **OAuth2 Success Page**: `/auth/oauth2/success` - Post-OAuth redirect handler

#### State Management
- **AuthContext**: React Context for global authentication state
- **localStorage Persistence**: Maintains login across sessions
- **TypeScript Interfaces**: Type-safe user data handling

## Security Implementation

### Password Security

#### Password Requirements
- **Minimum Length**: 8 characters
- **Maximum Length**: 128 characters
- **Character Requirements**:
  - At least one uppercase letter (A-Z)
  - At least one lowercase letter (a-z)
  - At least one digit (0-9)
  - At least one special character (@#$%^&+=!)

#### Security Validations
- **Common Password Detection**: Blocks weak passwords (password, 123456, etc.)
- **Repeated Character Prevention**: No more than 2 consecutive identical characters
- **Pattern Validation**: Regex enforcement of complexity requirements
- **Strength Calculation**: Real-time 5-point scoring system

### Username Security

#### Username Requirements
- **Length**: 3-30 characters
- **Pattern**: Must start with letter or number
- **Allowed Characters**: Letters, numbers, underscores, hyphens
- **Prohibited Names**: Reserved system usernames (admin, root, api, etc.)
- **Consecutive Characters**: No consecutive underscores or hyphens

### Input Validation

#### Backend Validation
```java
@ValidPassword
@ValidUsername
@Email
@Pattern(regexp = "^[a-zA-Z\\s'-]*$") // Names
@Size(min = 3, max = 30) // Length constraints
@NotBlank // Required fields
```

#### Frontend Validation
- **Real-time Feedback**: Immediate validation as user types
- **Debounced API Calls**: 500ms delay for availability checking
- **Visual Indicators**: Checkmarks, X marks, loading spinners
- **Error Messages**: Specific, helpful feedback

### Data Sanitization

#### Backend Sanitization
```java
private String sanitizeInput(String input) {
    return input.trim()
               .replaceAll("[<>\"'&]", "") // Remove XSS characters
               .replaceAll("\\s+", " "); // Normalize whitespace
}
```

#### Frontend Protection
- **React Built-in**: Automatic XSS protection through JSX
- **Input Constraints**: maxLength, pattern attributes
- **Type Validation**: TypeScript interfaces for data integrity

## Database Schema

### User Table Structure
```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    username VARCHAR(30) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    avatar_url TEXT,
    provider VARCHAR(20) DEFAULT 'LOCAL',
    provider_id VARCHAR(255),
    email_verified BOOLEAN DEFAULT FALSE,
    enabled BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### Related Tables
```sql
-- Dietary Preferences (Many-to-Many)
CREATE TABLE user_dietary_preferences (
    user_id BIGINT REFERENCES users(id),
    dietary_preferences VARCHAR(50)
);

-- Food Allergies (One-to-Many)
CREATE TABLE user_food_allergies (
    user_id BIGINT REFERENCES users(id),
    food_allergies VARCHAR(255)
);
```

### Indexes and Constraints
- **Primary Key**: Auto-incrementing ID
- **Unique Constraints**: Username and email
- **Foreign Keys**: Proper referential integrity
- **Check Constraints**: Enum validation on provider field

## API Endpoints

### Authentication Endpoints

#### POST /api/auth/signup
**Purpose**: Register new user account

**Request Body**:
```json
{
    "username": "string",
    "email": "string",
    "password": "string",
    "confirmPassword": "string",
    "firstName": "string",
    "lastName": "string"
}
```

**Response**:
```json
{
    "message": "Account created successfully! Welcome to Foodsie!",
    "success": true,
    "user": {
        "id": 1,
        "username": "johndoe",
        "email": "john@example.com",
        "displayName": "John Doe",
        // ... other user fields
    }
}
```

#### POST /api/auth/login
**Purpose**: Authenticate existing user

**Request Body**:
```json
{
    "emailOrUsername": "string",
    "password": "string"
}
```

#### POST /api/auth/check-availability
**Purpose**: Check username/email availability

**Request Body**:
```json
{
    "username": "string",
    "email": "string"
}
```

**Response**:
```json
{
    "emailAvailable": true,
    "usernameAvailable": false
}
```

### OAuth2 Endpoints

#### GET /oauth2/authorization/google
**Purpose**: Initiate Google OAuth2 flow

#### GET /api/oauth2/user
**Purpose**: Get current OAuth2 user information

## Frontend Implementation

### Authentication Context

```typescript
interface AuthContextType {
    user: User | null;
    isAuthenticated: boolean;
    isLoading: boolean;
    signIn: (userData: User) => void;
    signOut: () => void;
}
```

### Password Strength Calculation

```typescript
interface PasswordStrength {
    score: number; // 0-5
    feedback: string[]; // Missing requirements
    color: string; // Visual indicator color
}
```

**Scoring System**:
- +1 point: Length >= 8 characters
- +1 point: Contains uppercase letter
- +1 point: Contains lowercase letter
- +1 point: Contains number
- +1 point: Contains special character
- -2 points: Contains common password patterns

### Real-time Validation

#### Availability Checking
```typescript
// Debounced API calls to prevent excessive requests
useEffect(() => {
    const timeoutId = setTimeout(() => {
        if (username && username.length >= 3) {
            checkUsernameAvailability(username);
        }
    }, 500);
    
    return () => clearTimeout(timeoutId);
}, [username]);
```

#### Form State Management
```typescript
interface FormData {
    username: string;
    email: string;
    password: string;
    confirmPassword: string;
    firstName: string;
    lastName: string;
}

interface FormErrors {
    [key: string]: string | undefined;
}
```

## Security Best Practices

### Input Validation
1. **Client-side Validation**: Immediate feedback, UX improvement
2. **Server-side Validation**: Security enforcement, data integrity
3. **Sanitization**: Remove dangerous characters
4. **Length Limits**: Prevent buffer overflow attacks

### Password Security
1. **Strong Policies**: Complex requirements
2. **Hashing**: BCrypt with appropriate cost factor
3. **No Storage**: Never store plain text passwords
4. **Validation**: Real-time strength checking

### Session Management
1. **Stateless Tokens**: JWT or session cookies
2. **Secure Storage**: HttpOnly, Secure, SameSite cookies
3. **Expiration**: Automatic logout after inactivity
4. **Logout**: Proper session cleanup

### Error Handling
1. **Generic Messages**: Don't expose system details
2. **Logging**: Record security events for monitoring
3. **Rate Limiting**: Prevent brute force attacks
4. **Validation**: Comprehensive input checking

## Testing Guidelines

### Backend Testing
```java
@Test
public void testPasswordValidation() {
    // Test weak passwords
    assertFalse(validator.isValid("password", context));
    assertFalse(validator.isValid("123456", context));
    
    // Test strong passwords
    assertTrue(validator.isValid("MyStr0ng!Pass", context));
}

@Test
public void testUsernameDuplication() {
    // Test existing username rejection
    // Test case sensitivity
    // Test sanitization
}
```

### Frontend Testing
```typescript
describe('SignUp Form', () => {
    test('validates password strength', () => {
        // Test password scoring
        // Test visual indicators
        // Test error messages
    });
    
    test('checks username availability', () => {
        // Test API calls
        // Test debouncing
        // Test error handling
    });
});
```

## OAuth2 Setup

### Google Cloud Console Configuration

1. **Create Project**: Set up Google Cloud Console project
2. **Enable APIs**: Google+ API and OAuth2 API
3. **Create Credentials**: OAuth 2.0 Client ID
4. **Configure URIs**:
   - Authorized redirect URI: `http://localhost:8080/login/oauth2/code/google`
   - Authorized JavaScript origins: `http://localhost:3000`, `http://localhost:8080`

### Environment Variables
```properties
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret
```

### Spring Security Configuration
```java
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        return http
            .oauth2Login(oauth2 -> oauth2
                .userInfoEndpoint(userInfo -> userInfo
                    .userService(oauth2UserService))
                .successHandler(oAuth2AuthenticationSuccessHandler))
            .build();
    }
}
```

## Error Messages

### Validation Error Messages

#### Password Errors
- "Password must be between 8 and 128 characters long"
- "Password must contain at least one digit, one lowercase letter, one uppercase letter, and one special character"
- "Password is too common. Please choose a more secure password"
- "Password cannot contain more than 2 consecutive identical characters"

#### Username Errors
- "Username must be between 3 and 30 characters long"
- "Username can only contain letters, numbers, underscores, and hyphens. Must start with a letter or number"
- "This username is not available. Please choose a different one"
- "Username cannot contain consecutive underscores or hyphens"

#### Registration Errors
- "An account with this email address already exists. Please use a different email or try signing in."
- "This username is already taken. Please choose a different username."
- "Passwords do not match!"

## Performance Considerations

### Database Optimization
- **Indexes**: Username and email for fast lookups
- **Connection Pooling**: Efficient database connections
- **Query Optimization**: Proper JPA relationships

### Frontend Optimization
- **Debouncing**: Reduce API calls for availability checking
- **Lazy Loading**: Load components when needed
- **Caching**: Cache validation results
- **Bundle Splitting**: Separate authentication code

### Security vs Performance
- **Hashing Cost**: Balance security and response time
- **Validation Complexity**: Comprehensive but efficient
- **Rate Limiting**: Prevent abuse without blocking legitimate users

## Monitoring and Logging

### Security Events to Log
- Failed login attempts
- Password reset requests
- Account creation events
- Unusual activity patterns
- OAuth2 authentication events

### Metrics to Track
- Registration conversion rates
- Password strength distribution
- Login success/failure rates
- OAuth2 vs email/password usage
- Form abandonment points

## Future Enhancements

### Planned Features
1. **Email Verification**: Verify email addresses before activation
2. **Two-Factor Authentication**: SMS or authenticator app 2FA
3. **Password Recovery**: Secure password reset flow
4. **Social Login**: Additional OAuth2 providers (Facebook, GitHub)
5. **Account Lockout**: Temporary lockout after failed attempts

### Security Improvements
1. **Rate Limiting**: API-level request throttling
2. **CAPTCHA**: Bot protection for registration
3. **Device Tracking**: Unusual login location detection
4. **Session Security**: Enhanced session management
5. **Audit Logging**: Comprehensive security event logging

## Maintenance

### Regular Tasks
1. **Security Updates**: Keep dependencies current
2. **Password Policy Review**: Update requirements as needed
3. **Log Analysis**: Monitor for security threats
4. **Performance Monitoring**: Track authentication metrics
5. **Backup Verification**: Ensure user data protection

### Troubleshooting

#### Common Issues
1. **OAuth2 Redirect Errors**: Check Google Console configuration
2. **Password Validation Failures**: Review password requirements
3. **Database Constraints**: Check unique constraint violations
4. **Session Issues**: Verify cookie configuration

#### Debug Steps
1. Check backend logs for validation errors
2. Verify database constraints and indexes
3. Test OAuth2 configuration with Google
4. Validate frontend form state management
5. Confirm API endpoint accessibility